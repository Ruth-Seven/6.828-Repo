
## Ex1 ~ Ex3
å¯¹ç…§ç€ï¼ŒCæºç å’Œå¯¹åº”çš„ disassembly æ–‡ä»¶ï¼Œä¸€å¹¶è·Ÿè¸ª GDB çš„è¡Œè¸ªï¼Œè¿™æ‰å…¥æ‰‹è¿™ä¸ª boot çš„è¿è¡Œã€‚ä¸ç„¶çœŸæ˜¯ä¸€å¤´é›¾æ°´ï¼Œå®˜æ–¹ç»™çš„ guild ä¹Ÿå¾ˆæ¸…æ™°å…³é”®ã€‚




questions:


At what point does the processor start executing 32-bit code? What exactly causes the switch from 16- to 32-bit mode?
> A: 
>  orl     $CR0_PE_ON, %eax
>     7c26:	66 83 c8 01          	or     $0x1,%ax
>  movl    %eax, %cr0
>         7c2a:	0f 22 c0             	mov    %eax,%cr0
>      
  
 



What is the last instruction of the boot loader executed, and what is the first instruction of the kernel it just loaded?
> the lastest instruction:
>  	  	((void (*)(void)) (ELFHDR->e_entry))();
>   7d81:	ff 15 18 00 01 00    	call   *0x10018
> 
> the first instruction:
>  0x10000c:	movw   $0x1234,0x472



Where is the first instruction of the kernel?
How does the boot loader decide how many sectors it must read in order to fetch the entire kernel from disk? Where does it find this information?
> 1. 0x10000c
> 2. boot loader get the information from the first section in kernel, which is loaded firstly by boot.
> 3. concretly, it read info from `	ph = (struct Proghdr *) ((uint8_t *) ELFHDR + ELFHDR->e_phoff);`









## EX4-6
4-5  easy
 
6: boot loaderæŠŠkernelçš„ä¸€éƒ¨åˆ† setionï¼Œè½½å…¥åˆ°å†…å­˜0x100000ã€‚æ¥ç€å°±è·³è½¬åˆ°é‚£ä¸ª kernel æŒ‡ä»¤ä¸Šå»ï¼

> æˆ‘æ€ä¹ˆè¿™ä¹ˆæ£’ğŸ‘ğŸ»
> è¿›å…¥kernel entry æ‰“æ–­ç‚¹ï¼š
>   b *0x7d81 // boot.asm ç»“æŸå¤„
>   b *0x0x10000c  // åŠ è½½çš„kernelå…¥å£ 


## Ex7
è¿›å…¥kernelåï¼Œ`movl %eax %cr0`å¼€å¯äº†è™šæ‹Ÿåœ°å€æœºåˆ¶ï¼ŒåŸæœ¬éƒ½æ˜¯çº¿æ€§åœ°å€ï¼Œéƒ½éšå½¢å˜æˆäº†è™šæ‹Ÿåœ°å€ã€‚åœ¨æ­¤ä¾‹ä¸­ï¼Œ`0x00100000`~ `0x00400000`å†…å®¹æ˜¯ booter è£…è½½çš„ï¼Œåœ°å€æ˜¯çº¿æ€§çš„ï¼Œç‰©ç†çš„ï¼Œå¼€å¯è™šæ‹Ÿæ˜ å°„åï¼Œ`entrypgdir.c` hard-coded çš„æ˜ å°„é¡µè¢«å¯ç”¨ï¼Œé«˜ä½çš„`0x0f010000`ç­‰åœ°å€éƒ½è¢«æ˜ å°„åˆ°ä½ä½`0x00100000`ã€‚ä¹Ÿå°±æ˜¯è¯´ç°åœ¨åœ¨è™šæ‹Ÿåœ°å€ä¸Šï¼Œæœ‰ä¸¤å—ç›¸åŒå†…å®¹çš„ç©ºé—´ã€‚



## Ex8

C å˜å‚å‡½æ•°å‚æ•°æ¶‰åŠåˆ°GCC`__builtin_va_**`è‡ªå»ºå‡½æ•°ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå˜å‚æ˜¯å¯ä»¥ç”¨ç¼–è¯‘å™¨å®ç°çš„ï¼

**1**
`kern/console.c`ç”¨`asm`ç¼–ç¨‹å’Œåº•å±‚ç»“æ„äº¤äº’ï¼Œå¹¶æä¾›é«˜çº§æ¥å£`cputchar()`ã€`getchar()`ã€`cputchar()` ã€‚å†…éƒ¨ `serail I/O`ã€`parallel port` å’Œ `cga/vga`ã€ `keyboard`é€šè¿‡`cons_intr`ä¼ é€’å‡½æ•°æŒ‡é’ˆè¿›è¡Œè§£è€¦ï¼ŒåŒæ—¶ç»Ÿä¸€æ•°æ®æ“ä½œä¸º consoleè¿›è¡Œæ•°æ®è¾“å…¥å’Œè¾“å‡ºæ“ä½œã€‚
>  // JJ: why use a shared buf for different input?
>  æ€ä¹ˆæ§åˆ¶è¾“å‡ºè®¾å¤‡å‘¢ï¼Ÿè²Œä¼¼éƒ½è¾“å‡º

`cprintf` ï¼šæœ‰`putch`, å¯¹åº” `console`
`snprintf`: æœ‰ `sprintputch`, å¯¹åº”`string buffer`

çœ‹å®Œæœ€å¤æ‚ã€æœ€å…³é”®çš„ä»ç¨‹åºæŠŠæ ¼å¼åŒ– string è½¬åŒ–ä¸º char çš„`vprintfmt`ï¼Œä¸å¾—ä¸æƒŠå¹ä¸‹æ„é€ çš„å·§å¦™ï¼šå¾ªç¯éå†ï¼Œç‰¹åˆ¤ escape charï¼Œé€šè¿‡æ ‡è®°å­—ç¬¦è·å–å„ä¸ª format å‚æ•°ï¼Œç­‰ç­‰ã€‚
å…¶ä¸­çš„`putch`å½¢å‚çš„ç±»å‹`void (*putch)(int, void*)`ç­¾åä¸­å‚æ•°åˆ†åˆ«ä»£è¡¨è¾“å‡º char å’Œè®°å½•è¾“å‡ºä¿¡æ¯çš„ç»“æ„çš„æŒ‡é’ˆã€‚å…¶å®`putch`å°±åƒä¸€å±‚åŒ…è£…ï¼Œéšè—æ‰åº•å±‚ä¸åŒå½¢å¼çš„ä¿®æ”¹å’Œå˜åŠ¨ï¼Œä»¥åŠè°ƒç”¨å‡½æ•°çš„ä¸åŒã€‚


**2**
å½“å†…å®¹è¶…è¿‡æ˜¾ç¤ºå®¹é‡ï¼Œåˆ·æ–°å¹¶ä¸Šç§»ä¸€è¡Œ vga/cga(å›¾å½¢é€‚é…å™¨ï¼‰çš„å†…å®¹ã€‚

**3**

`fmt` points "x %d, ...." string. `ap`è‡ªç„¶å°±æ˜¯ x,y,zã€‚

call sequenceï¼š
   - cprintf
   - vcprintf
   - vprintfmt
   - va_arg  + putch
   - cputchar
   - cons_putc

the sequence of arguemnt of cons_putc is a char list of the formated string.
va_arg æ¯æ¬¡ï¼Œè°ƒç”¨ï¼Œè‡ªç„¶å°‘äº†ä¸€ä¸ªå‚æ•°ã€‚
vcprintfå°±æ›´ç®€å•äº†ä¸€ä¸ª fmtï¼Œä¸€ä¸ª va_list

**4**
å‡è®¾å­˜å‚¨æ–¹å¼ä¸º little Endian
output: `He110 World` (è¿˜æœ‰ä¸ª\0æ²¡è¾“å‡ºï¼‰

å¦‚æœæ˜¯ big-endianï¼Œ å¾—æœ‰i=0x726c6400ï¼Œ 57616 ä¸éœ€è¦åŠ¨.

**5**
æŒ‰ç†æ¥è¯´åº”è¯¥ä¼šæŠ¥é”™ï¼Œè¿™å¾—çœ‹ `va_arg(*ap, type)`å¯¹ç©ºå€¼çš„ååº”ã€‚


**6**
ä»–çš„æ„æ€æ˜¯æ”¹æˆ`cprintf(..., const char *fmt)`?


**challenge** æœ‰ç‚¹éš¾ï¼Œå…ˆæ”¾ä¸€æ”¾

## ex9
 > æ„ä¹‰ä¸å¤ªæ˜ç¡®


ebpè®¾ç½®åœ¨
```assembly
	# Clear the frame pointer register (EBP)
	# so that once we get into debugging C code,
	# stack backtraces will be terminated properly.
	movl	$0x0,%ebp			# nuke frame pointer
  f010002f:	bd 00 00 00 00       	mov    $0x0,%ebp

    # Set the stack pointer
	movl	$(bootstacktop),%esp
f0100034:	bc 00 00 11 f0       	mov    $0xf0110000,%esp
```

å†…å­˜ä» 0xf0110000 å¼€å§‹åˆ†é…ã€‚
(ä¸è¿‡æœ€å¼€å§‹ ebp çš„å€¼ç¡®å®æ˜¯ 0x000
ä¿ç•™çš„ç©ºé—´æœ‰ å¤šå°‘ï¼Ÿï¼Ÿï¼Ÿ

ä¸€å¼€å§‹æ ˆæŒ‡é’ˆæŒ‡å‘0xf0110000
## Ex1 ~ Ex3
å¯¹ç…§ç€ï¼ŒCæºç å’Œå¯¹åº”çš„ disassembly æ–‡ä»¶ï¼Œä¸€å¹¶è·Ÿè¸ª GDB çš„è¡Œè¸ªï¼Œè¿™æ‰å…¥æ‰‹è¿™ä¸ª boot çš„è¿è¡Œã€‚ä¸ç„¶çœŸæ˜¯ä¸€å¤´é›¾æ°´ï¼Œå®˜æ–¹ç»™çš„ guild ä¹Ÿå¾ˆæ¸…æ™°å…³é”®ã€‚




questions:


At what point does the processor start executing 32-bit code? What exactly causes the switch from 16- to 32-bit mode?
> A: 
>  orl     $CR0_PE_ON, %eax
>     7c26:	66 83 c8 01          	or     $0x1,%ax
>  movl    %eax, %cr0
>         7c2a:	0f 22 c0             	mov    %eax,%cr0
>      
  
 



What is the last instruction of the boot loader executed, and what is the first instruction of the kernel it just loaded?
> the lastest instruction:
>  	  	((void (*)(void)) (ELFHDR->e_entry))();
>   7d81:	ff 15 18 00 01 00    	call   *0x10018
> 
> the first instruction:
>  0x10000c:	movw   $0x1234,0x472



Where is the first instruction of the kernel?
How does the boot loader decide how many sectors it must read in order to fetch the entire kernel from disk? Where does it find this information?
> 1. 0x10000c
> 2. boot loader get the information from the first section in kernel, which is loaded firstly by boot.
> 3. concretly, it read info from `	ph = (struct Proghdr *) ((uint8_t *) ELFHDR + ELFHDR->e_phoff);`









## EX4-6
4-5  easy
 
6: boot loaderæŠŠkernelçš„ä¸€éƒ¨åˆ† setionï¼Œè½½å…¥åˆ°å†…å­˜0x100000ã€‚æ¥ç€å°±è·³è½¬åˆ°é‚£ä¸ª kernel æŒ‡ä»¤ä¸Šå»ï¼

> æˆ‘æ€ä¹ˆè¿™ä¹ˆæ£’ğŸ‘ğŸ»
> è¿›å…¥kernel entry æ‰“æ–­ç‚¹ï¼š
>   b *0x7d81 // boot.asm ç»“æŸå¤„
>   b *0x0x10000c  // åŠ è½½çš„kernelå…¥å£ 


## Ex7
è¿›å…¥kernelåï¼Œ`movl %eax %cr0`å¼€å¯äº†è™šæ‹Ÿåœ°å€æœºåˆ¶ï¼ŒåŸæœ¬éƒ½æ˜¯çº¿æ€§åœ°å€ï¼Œéƒ½éšå½¢å˜æˆäº†è™šæ‹Ÿåœ°å€ã€‚åœ¨æ­¤ä¾‹ä¸­ï¼Œ`0x00100000`~ `0x00400000`å†…å®¹æ˜¯ booter è£…è½½çš„ï¼Œåœ°å€æ˜¯çº¿æ€§çš„ï¼Œç‰©ç†çš„ï¼Œå¼€å¯è™šæ‹Ÿæ˜ å°„åï¼Œ`entrypgdir.c` hard-coded çš„æ˜ å°„é¡µè¢«å¯ç”¨ï¼Œé«˜ä½çš„`0x0f010000`ç­‰åœ°å€éƒ½è¢«æ˜ å°„åˆ°ä½ä½`0x00100000`ã€‚ä¹Ÿå°±æ˜¯è¯´ç°åœ¨åœ¨è™šæ‹Ÿåœ°å€ä¸Šï¼Œæœ‰ä¸¤å—ç›¸åŒå†…å®¹çš„ç©ºé—´ã€‚



## Ex8

C å˜å‚å‡½æ•°å‚æ•°æ¶‰åŠåˆ°GCC`__builtin_va_**`è‡ªå»ºå‡½æ•°ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå˜å‚æ˜¯å¯ä»¥ç”¨ç¼–è¯‘å™¨å®ç°çš„ï¼

**1**
`kern/console.c`ç”¨`asm`ç¼–ç¨‹å’Œåº•å±‚ç»“æ„äº¤äº’ï¼Œå¹¶æä¾›é«˜çº§æ¥å£`cputchar()`ã€`getchar()`ã€`cputchar()` ã€‚å†…éƒ¨ `serail I/O`ã€`parallel port` å’Œ `cga/vga`ã€ `keyboard`é€šè¿‡`cons_intr`ä¼ é€’å‡½æ•°æŒ‡é’ˆè¿›è¡Œè§£è€¦ï¼ŒåŒæ—¶ç»Ÿä¸€æ•°æ®æ“ä½œä¸º consoleè¿›è¡Œæ•°æ®è¾“å…¥å’Œè¾“å‡ºæ“ä½œã€‚
>  // JJ: why use a shared buf for different input?
>  æ€ä¹ˆæ§åˆ¶è¾“å‡ºè®¾å¤‡å‘¢ï¼Ÿè²Œä¼¼éƒ½è¾“å‡º

`cprintf` ï¼šæœ‰`putch`, å¯¹åº” `console`
`snprintf`: æœ‰ `sprintputch`, å¯¹åº”`string buffer`

çœ‹å®Œæœ€å¤æ‚ã€æœ€å…³é”®çš„ä»ç¨‹åºæŠŠæ ¼å¼åŒ– string è½¬åŒ–ä¸º char çš„`vprintfmt`ï¼Œä¸å¾—ä¸æƒŠå¹ä¸‹æ„é€ çš„å·§å¦™ï¼šå¾ªç¯éå†ï¼Œç‰¹åˆ¤ escape charï¼Œé€šè¿‡æ ‡è®°å­—ç¬¦è·å–å„ä¸ª format å‚æ•°ï¼Œç­‰ç­‰ã€‚
å…¶ä¸­çš„`putch`å½¢å‚çš„ç±»å‹`void (*putch)(int, void*)`ç­¾åä¸­å‚æ•°åˆ†åˆ«ä»£è¡¨è¾“å‡º char å’Œè®°å½•è¾“å‡ºä¿¡æ¯çš„ç»“æ„çš„æŒ‡é’ˆã€‚å…¶å®`putch`å°±åƒä¸€å±‚åŒ…è£…ï¼Œéšè—æ‰åº•å±‚ä¸åŒå½¢å¼çš„ä¿®æ”¹å’Œå˜åŠ¨ï¼Œä»¥åŠè°ƒç”¨å‡½æ•°çš„ä¸åŒã€‚


**2**
å½“å†…å®¹è¶…è¿‡æ˜¾ç¤ºå®¹é‡ï¼Œåˆ·æ–°å¹¶ä¸Šç§»ä¸€è¡Œ vga/cga(å›¾å½¢é€‚é…å™¨ï¼‰çš„å†…å®¹ã€‚

**3**

`fmt` points "x %d, ...." string. `ap`è‡ªç„¶å°±æ˜¯ x,y,zã€‚

call sequenceï¼š
   - cprintf
   - vcprintf
   - vprintfmt
   - va_arg  + putch
   - cputchar
   - cons_putc

the sequence of arguemnt of cons_putc is a char list of the formated string.
va_arg æ¯æ¬¡ï¼Œè°ƒç”¨ï¼Œè‡ªç„¶å°‘äº†ä¸€ä¸ªå‚æ•°ã€‚
vcprintfå°±æ›´ç®€å•äº†ä¸€ä¸ª fmtï¼Œä¸€ä¸ª va_list

**4**
å‡è®¾å­˜å‚¨æ–¹å¼ä¸º little Endian
output: `He110 World` (è¿˜æœ‰ä¸ª\0æ²¡è¾“å‡ºï¼‰

å¦‚æœæ˜¯ big-endianï¼Œ å¾—æœ‰i=0x726c6400ï¼Œ 57616 ä¸éœ€è¦åŠ¨.

**5**
æŒ‰ç†æ¥è¯´åº”è¯¥ä¼šæŠ¥é”™ï¼Œè¿™å¾—çœ‹ `va_arg(*ap, type)`å¯¹ç©ºå€¼çš„ååº”ã€‚


**6**
ä»–çš„æ„æ€æ˜¯æ”¹æˆ`cprintf(..., const char *fmt)`?


**challenge** æœ‰ç‚¹éš¾ï¼Œå…ˆæ”¾ä¸€æ”¾

## ex9
 > æ„ä¹‰ä¸å¤ªæ˜ç¡®


ebpè®¾ç½®åœ¨
```assembly
	# Clear the frame pointer register (EBP)
	# so that once we get into debugging C code,
	# stack backtraces will be terminated properly.
	movl	$0x0,%ebp			# nuke frame pointer
  f010002f:	bd 00 00 00 00       	mov    $0x0,%ebp

    # Set the stack pointer
	movl	$(bootstacktop),%esp
f0100034:	bc 00 00 11 f0       	mov    $0xf0110000,%esp
```

å†…å­˜ä» 0xf0110000 å¼€å§‹åˆ†é…ã€‚
(ä¸è¿‡æœ€å¼€å§‹ ebp çš„å€¼ç¡®å®æ˜¯ 0x000
ä¿ç•™çš„ç©ºé—´æœ‰ å¤šå°‘ï¼Ÿï¼Ÿï¼Ÿ

ä¸€å¼€å§‹æ ˆæŒ‡é’ˆæŒ‡å‘0xf0110000

kernel é€šè¿‡ä¿å­˜ ebp ä¿å­˜ä¸€ä¸ªå‡½æ•°çš„é¡¶ç«¯ï¼Œesp ä¿å­˜æ ˆæ ˆå¸§çš„æœ«ç«¯ã€‚


>  (Why can't the backtrace code detect how many arguments there actually are? How could this limitation be fixed?)


## ex10
è°ƒè¯•ç»“æœå¦‚ä¸‹, ç»è¿‡éªŒè¯ï¼Œæ²¡çœ‹å‡ºæ¥å’Œä¼ ç»Ÿçš„ C calling æœ‰å•¥å·®åˆ«

```assembly 

=> 0xf010006c <test_backtrace+44>:	jle    0xf0100097 <test_backtrace+87>

Breakpoint 2, 0xf010006c in test_backtrace (x=4) at kern/init.c:15 /
15		if (x > 0)
(gdb) info reg
eax            0x0                 0
ecx            0x3d4               980
edx            0x3d5               981
ebx            0xf0111308          -267316472
esp            0xf010ff90          0xf010ff90 
ebp            0xf010ff98          0xf010ff98
esi            0x3                 3
edi            0x0                 0
eip            0xf010006c          0xf010006c <test_backtrace+44>
eflags         0x6                 [ PF ]
cs             0x8                 8
ss             0x10                16
ds             0x10                16
es             0x10                16
fs             0x10                16
gs             0x10                16
(gdb) x/32w $esp
0xf010ff90:	0xf0111308($esp)	0x00000004ï¼ˆlocal varï¼‰	0xf010ffb8($ebp)	0xf010007aï¼ˆreturn addresssï¼‰
0xf010ffa0:	0x00000003ï¼ˆparametersï¼‰	0x00000004	0x00000000	0xf010004e
0xf010ffb0:	0xf0111308	0x00000005	0xf010ffd8	0xf010007a
0xf010ffc0:	0x00000004	0x00000005	0x00000000	0xf010004e
0xf010ffd0:	0xf0111308	0x00010094	0xf010fff8	0xf01000fc
0xf010ffe0:	0x00000005	0x00001aac	0x00000640	0x00000000
0xf010fff0:	0x00000000	0x00010094	0x00000000	0xf010003e
0xf0110000 <entry_pgtable>:	0x00000003	0x00001003	0x00002003	0x00003003

```
ä¸Šé¢ä»£ç æ‰€ç¤ºï¼Œå¯ä»¥é€’å½’å¾—è·å–ä¸€ä¸ªæ ˆå¸§çš„ ebpï¼ŒåŒæ—¶æ‰“å°ç›¸å…³ä¿¡æ¯ï¼Œex10å°±å®Œæˆäº†



## ex11



è¿™ä¸ªå®éªŒåšçš„æ˜¯debugçš„åŸç†ï¼Œç¼–è¯‘äº§ç”Ÿçš„stabï¼Œé€šè¿‡é“¾æ¥å™¨è®¾ç½®é“¾æ¥åœ°å€å’Œè½½å…¥åœ°å€ï¼ŒåŒæ—¶ä»£ç è®¾ç½®äº†stabæ•°æ®ç»“æ„çš„ä¸Šä¸‹ç•Œã€‚stabæŒ‡é’ˆè‡ªç„¶æŒ‡å‘äº†ï½“ï½”ï½ï½‚çš„ä¸Šç•Œã€‚

> å‘ç°å¾ˆå¤šé”™è¯¯æ¥è‡ªäºå¯¹ C çš„ä¸ç†Ÿç»ƒï¼Œç•™ä¸‹äº†ç—›è‹¦çš„æ³ªæ°´~

Stabå…·ä½“å†…å®¹å¯ä»¥ç”¨`objdump -G obj/kern/kernel`æŸ¥çœ‹

é“¾æ¥åœ°å€ç”¨ `objdupm -h obj/kern/kernel`æŸ¥çœ‹

é“¾æ¥è¿‡ç¨‹åœ¨`kernel.ld`æŸ¥çœ‹


å®éªŒè¦æ±‚ç”¨æœç´¢å¤åˆ¶æœç´¢å…·ä½“ä»£ç ï¼Œæœç´¢è¿‡ç¨‹ä¸è¡¨ï¼Œå…·ä½“åˆ°è·å–`N_SLINE` stab è¡¨çš„ value å³å¯



kernel é€šè¿‡ä¿å­˜ ebp ä¿å­˜ä¸€ä¸ªå‡½æ•°çš„é¡¶ç«¯ï¼Œesp ä¿å­˜æ ˆæ ˆå¸§çš„æœ«ç«¯ã€‚


>  (Why can't the backtrace code detect how many arguments there actually are? How could this limitation be fixed?)


## ex10
è°ƒè¯•ç»“æœå¦‚ä¸‹, ç»è¿‡éªŒè¯ï¼Œæ²¡çœ‹å‡ºæ¥å’Œä¼ ç»Ÿçš„ C calling æœ‰å•¥å·®åˆ«

```assembly 

=> 0xf010006c <test_backtrace+44>:	jle    0xf0100097 <test_backtrace+87>

Breakpoint 2, 0xf010006c in test_backtrace (x=4) at kern/init.c:15 /
15		if (x > 0)
(gdb) info reg
eax            0x0                 0
ecx            0x3d4               980
edx            0x3d5               981
ebx            0xf0111308          -267316472
esp            0xf010ff90          0xf010ff90 
ebp            0xf010ff98          0xf010ff98
esi            0x3                 3
edi            0x0                 0
eip            0xf010006c          0xf010006c <test_backtrace+44>
eflags         0x6                 [ PF ]
cs             0x8                 8
ss             0x10                16
ds             0x10                16
es             0x10                16
fs             0x10                16
gs             0x10                16
(gdb) x/32w $esp
0xf010ff90:	0xf0111308($esp)	0x00000004ï¼ˆlocal varï¼‰	0xf010ffb8($ebp)	0xf010007aï¼ˆreturn addresssï¼‰
0xf010ffa0:	0x00000003ï¼ˆparametersï¼‰	0x00000004	0x00000000	0xf010004e
0xf010ffb0:	0xf0111308	0x00000005	0xf010ffd8	0xf010007a
0xf010ffc0:	0x00000004	0x00000005	0x00000000	0xf010004e
0xf010ffd0:	0xf0111308	0x00010094	0xf010fff8	0xf01000fc
0xf010ffe0:	0x00000005	0x00001aac	0x00000640	0x00000000
0xf010fff0:	0x00000000	0x00010094	0x00000000	0xf010003e
0xf0110000 <entry_pgtable>:	0x00000003	0x00001003	0x00002003	0x00003003

```
ä¸Šé¢ä»£ç æ‰€ç¤ºï¼Œå¯ä»¥é€’å½’å¾—è·å–ä¸€ä¸ªæ ˆå¸§çš„ ebpï¼ŒåŒæ—¶æ‰“å°ç›¸å…³ä¿¡æ¯ï¼Œex10å°±å®Œæˆäº†



## ex11



è¿™ä¸ªå®éªŒåšçš„æ˜¯debugçš„åŸç†ï¼Œç¼–è¯‘äº§ç”Ÿçš„stabï¼Œé€šè¿‡é“¾æ¥å™¨è®¾ç½®é“¾æ¥åœ°å€å’Œè½½å…¥åœ°å€ï¼ŒåŒæ—¶ä»£ç è®¾ç½®äº†stabæ•°æ®ç»“æ„çš„ä¸Šä¸‹ç•Œã€‚stabæŒ‡é’ˆè‡ªç„¶æŒ‡å‘äº†ï½“ï½”ï½ï½‚çš„ä¸Šç•Œã€‚

> å‘ç°å¾ˆå¤šé”™è¯¯æ¥è‡ªäºå¯¹ C çš„ä¸ç†Ÿç»ƒï¼Œç•™ä¸‹äº†ç—›è‹¦çš„æ³ªæ°´~

Stabå…·ä½“å†…å®¹å¯ä»¥ç”¨`objdump -G obj/kern/kernel`æŸ¥çœ‹

é“¾æ¥åœ°å€ç”¨ `objdupm -h obj/kern/kernel`æŸ¥çœ‹

é“¾æ¥è¿‡ç¨‹åœ¨`kernel.ld`æŸ¥çœ‹


å®éªŒè¦æ±‚ç”¨æœç´¢å¤åˆ¶æœç´¢å…·ä½“ä»£ç ï¼Œæœç´¢è¿‡ç¨‹ä¸è¡¨ï¼Œå…·ä½“åˆ°è·å–`N_SLINE` stab è¡¨çš„ value å³å¯

